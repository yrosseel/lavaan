\name{sem}
\alias{sem}
\title{Fit Structural Equation Models}
\description{
Fit a Structural Equation Model (SEM).}
\usage{
sem(model.syntax = '', meanstructure = "default", fixed.x = "default",
    orthogonal = FALSE, std.lv = FALSE, data = NULL, std.ov = FALSE,
    missing = "default", sample.cov = NULL, sample.mean = NULL, 
    sample.nobs = NULL, group = NULL, group.equal = "",
    group.partial = "", constraints = '', estimator = "default", 
    likelihood = "default", information = "default", se = "default", 
    test = "default", mimic = "default", representation = "default", 
    do.fit = TRUE, verbose = FALSE, warn = TRUE, debug = FALSE)
}
\arguments{
\item{model.syntax}{The model syntax specifying the model. See 
    \code{\link{model.syntax}} for more information.}
\item{meanstructure}{If \code{TRUE}, the means of the observed
    variables enter the model. If \code{"default"}, the value is set based
    on the user-specified model, and/or the values of other arguments.}
\item{fixed.x}{If \code{TRUE}, the exogenous `x' covariates are considered
    fixed variables and the means, variances and covariances of these variables
    are fixed to their sample values. If \code{FALSE}, they are considered
    random, and the means, variances and covariances are free parameters. If
    \code{"default"}, the value is set depending on the mimic option.}
\item{orthogonal}{If \code{TRUE}, the exogenous latent variables
    are assumed to be uncorrelated.}
\item{std.lv}{If \code{TRUE}, the metric of each latent variable is
    determined by fixing their variances to 1.0. If \code{FALSE}, the metric
    of each latent variable is determined by fixing the factor loading of the
    first indicator to 1.0.}
\item{data}{An optional data frame containing the observed variables used in
    the model.}
\item{std.ov}{If \code{TRUE}, all observed variables are standardized
    before entering the analysis.}
\item{missing}{If \code{"listwise"}, cases with missing values are removed
    listwise from the data frame before analysis. If \code{"direct"} or
    \code{"ml"} or \code{"fiml"} and the estimator is maximum likelihood,
    Full Information Maximum Likelihood (FIML) estimation is used using all
    available data in the data frame. This is only valid if the data are
    missing completely at random (MCAR) or missing at random (MAR). If
    \code{"default"}, the value is set depending on the estimator and the
    mimic option.}
\item{sample.cov}{Numeric matrix. A sample variance-covariance matrix.
    The rownames must contain the observed variable names.
    For a multiple group analysis, a list with a variance-covariance matrix
    for each group.}
\item{sample.mean}{A sample mean vector. For a multiple group analysis,
    a list with a mean vector for each group.}
\item{sample.nobs}{Number of observations if the full data frame is missing
    and only sample moments are given. For a multiple group analysis, a list
    or a vector with the number of observations for each group.}
\item{group}{A variable name in the data frame defining the groups in a
    multiple group analysis.}
 \item{group.equal}{A vector of character strings. Only used in
    a multiple group analysis. Can be one or more of the following: 
    \code{"loadings"}, \code{"intercepts"},
    \code{"means"}, \code{"regressions"}, \code{"residuals"} or   
    \code{"covariances"}, specifying the pattern of equality
    constraints across multiple groups.}
\item{group.partial}{A vector of character strings containing the labels
    of the parameters which should be free in all groups (thereby
    overriding the group.equal argument for some specific parameters).}
\item{constraints}{Additional (in)equality constraints not yet included in the
    model syntax. See \code{\link{model.syntax}} for more information.}
\item{estimator}{The estimator to be used. Can be one of the following:
    \code{"ML"} for maximum likelihood, \code{"GLS"} for generalized least 
    squares, \code{"WLS"} for weighted least squares (sometimes called ADF 
    estimation), \code{"MLM"} for maximum likelihood estimation with robust
    standard errors and a Satorra-Bentler scaled test statistic,
    \code{"MLF"} for maximum likelihood estimation with standard errors 
    based on first-order derivatives and a conventional test statistic,
    \code{"MLR"} for maximum likelihood estimation with robust `Huber-White' 
    standard errors and a scaled test statistic which is asymptotically 
    equivalent to the Yuan-Bentler T2-star test statistic. Note that the 
    \code{"MLM"}, \code{"MLF"} and \code{"MLR"} choices only affect the
    standard errors and the test statistic. They also imply 
    \code{mimic="Mplus"}.}
\item{likelihood}{Only relevant for ML estimation. If \code{"wishart"},
    the wishart likelihood approach is used. In this approach, the covariance
    matrix has been divided by N-1, and both standard errors and test 
    statistics are based on N-1. 
    If \code{"normal"}, the normal likelihood approach is used. Here,
    the covariance matrix has been divided by N, and both standard errors 
    and test statistics are based on N. If \code{"default"}, it depends
    on the mimic option: if \code{mimic="Mplus"}, normal likelihood is used;
    otherwise, wishart likelihood is used.}
\item{information}{If \code{"expected"}, the expected information matrix
    is used (to compute the standard errors). If \code{"observed"}, the
    observed information matrix is used. If \code{"default"}, the value is 
    set depending on the estimator and the mimic option.}
\item{se}{If \code{"standard"}, conventional standard errors 
    are computed based on inverting the (expected or observed) information 
    matrix. If \code{"first.order"}, standard errors are computed based on 
    first-order derivatives. If \code{"robust.mlm"}, conventional robust 
    standard errors are computed.
    If \code{"robust.mlr"},
    standard errors are computed based on the `mlr' (aka pseudo ML, 
    Huber-White) approach.
    If \code{"robust"}, either \code{"robust.mlm"} or \code{"robust.mlr"} is
    used depending on the estimator, the mimic option, and whether the data
    are complete or not. If \code{"none"}, no standard errors are computed.}
\item{test}{If \code{"standard"}, a conventional chi-square test is computed.
    If \code{"Satorra-Bentler"}, a Satorra-Bentler scaled test statistic is
    computed. If \code{"Yuan-Bentler"}, a Yuan-Bentler scaled test statistic
    is computed. If \code{"default"}, the value depends on the
    values of other arguments.}
\item{mimic}{If \code{"Mplus"}, an attempt is made to mimic the Mplus 
    program. If \code{"EQS"}, an attempt is made to mimic the EQS program.
    If \code{"default"}, the value is (currently) set to \code{"Mplus"}.}
\item{representation}{If \code{"LISREL"} the classical LISREL matrix 
    representation is used to represent the model (using the all-y variant).}
\item{do.fit}{If \code{FALSE}, the model is not fit, and the current
    starting values of the model parameters are preserved.}
\item{verbose}{If \code{TRUE}, the function value is printed out during
    each iteration.}
\item{warn}{If \code{TRUE}, some (possibly harmless) warnings are printed
    out during the iterations.}
\item{debug}{If \code{TRUE}, debugging information is printed out.}
}
\details{
    The \code{sem} function is a wrapper for the more general
    \code{\link{lavaan}} function, using the following default arguments:
    \code{int.ov.free = TRUE}, \code{int.lv.free = FALSE},
    \code{auto.fix.first = TRUE} (unless \code{std.lv = TRUE}),
    \code{auto.fix.single = TRUE}, \code{auto.var = TRUE},
    \code{auto.cov.lv.x = TRUE}, and \code{auto.cov.y = TRUE}.
}
\value{
  An object of class \code{\linkS4class{lavaan}}, for which several methods
  are available, including a \code{summary} method.
}
\seealso{
\code{\link{lavaan}}
}
\examples{
## The industrialization and Political Democracy Example 
## Bollen (1989), page 332
model <- ' 
  # latent variable definitions
     ind60 =~ x1 + x2 + x3
     dem60 =~ y1 + y2 + y3 + y4
     dem65 =~ y5 + equal("dem60=~y2")*y6 
                 + equal("dem60=~y3")*y7 
                 + equal("dem60=~y4")*y8

  # regressions
    dem60 ~ ind60
    dem65 ~ ind60 + dem60

  # residual correlations
    y1 ~~ y5
    y2 ~~ y4 + y6
    y3 ~~ y7
    y4 ~~ y8
    y6 ~~ y8
'

fit <- sem(model, data=PoliticalDemocracy)
summary(fit, fit.measures=TRUE)
}
